{
  "_args": [
    [
      {
        "raw": "react-hotkeys@^2.0.0-pre5",
        "scope": null,
        "escapedName": "react-hotkeys",
        "name": "react-hotkeys",
        "rawSpec": "^2.0.0-pre5",
        "spec": ">=2.0.0-pre5 <3.0.0",
        "type": "range"
      },
      "/Users/windpursuer/IdeaProjects/tb/sedum/sedum-client"
    ]
  ],
  "_cnpm_publish_time": 1562914304141,
  "_from": "react-hotkeys@^2.0.0-pre5",
  "_hasShrinkwrap": false,
  "_id": "react-hotkeys@2.0.0",
  "_location": "/react-hotkeys",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-hotkeys_2.0.0_1562914303945_0.42802834108665966"
  },
  "_npmUser": {
    "name": "greena13",
    "email": "greenhama13@gmail.com"
  },
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-hotkeys@^2.0.0-pre5",
    "scope": null,
    "escapedName": "react-hotkeys",
    "name": "react-hotkeys",
    "rawSpec": "^2.0.0-pre5",
    "spec": ">=2.0.0-pre5 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://registry.npm.souche-inc.com/react-hotkeys/download/react-hotkeys-2.0.0.tgz",
  "_shasum": "a7719c7340cbba888b0e9184f806a9ec0ac2c53f",
  "_shrinkwrap": null,
  "_spec": "react-hotkeys@^2.0.0-pre5",
  "_where": "/Users/windpursuer/IdeaProjects/tb/sedum/sedum-client",
  "author": {
    "name": "Aleck Greenham"
  },
  "bugs": {
    "url": "https://github.com/greena13/react-hotkeys/issues"
  },
  "contributors": [
    {
      "name": "Chris Pearce",
      "email": "hello@chrispearce.me",
      "url": "chrispearce.co"
    }
  ],
  "dependencies": {
    "prop-types": "^15.6.1"
  },
  "description": "A declarative library for handling hotkeys and focus within a React application",
  "devDependencies": {
    "@babel/cli": "^7.2.3",
    "@babel/core": "^7.2.2",
    "@babel/plugin-proposal-class-properties": "^7.2.3",
    "@babel/preset-env": "^7.2.3",
    "@babel/preset-react": "^7.0.0",
    "@babel/register": "^7.0.0",
    "babel-eslint": "10.0.1",
    "babel-plugin-transform-node-env-inline": "^0.4.3",
    "babel-preset-minify": "^0.5.0",
    "chai": "^4.1.2",
    "chai-enzyme": "^1.0.0-beta.0",
    "cheerio": "^1.0.0-0",
    "cross-env": "^5.2.0",
    "css-loader": "^2.1.0",
    "enzyme": "^3.3.0",
    "enzyme-adapter-react-16": "^1.1.1",
    "eslint": "5.12.0",
    "eslint-config-react-app": "^3.0.6",
    "eslint-plugin-flowtype": "^3.2.1",
    "eslint-plugin-import": "^2.6.0",
    "eslint-plugin-jsx-a11y": "^6.1.2",
    "eslint-plugin-react": "^7.1.0",
    "estraverse": "^4.2.0",
    "jsdom": "^13.1.0",
    "jsdom-global": "^3.0.2",
    "lodash.random": "^3.2.0",
    "mocha": "^5.2.0",
    "prompt": "^1.0.0",
    "react": "^16.3.2",
    "react-dom": "^16.7.0",
    "rollup": "^1.1.0",
    "rollup-plugin-babel": "^4.3.0",
    "rollup-plugin-license": "^0.7.0",
    "rollup-plugin-strip": "^1.2.0",
    "rollup-plugin-uglify": "^6.0.0",
    "simulant": "^0.2.2",
    "sinon": "^7.2.2",
    "sinon-chai": "^3.0.0",
    "style-loader": "^0.23.1"
  },
  "directories": {
    "example": "examples",
    "src": "src",
    "src/vendor": "src/vendor",
    "test": "test"
  },
  "dist": {
    "shasum": "a7719c7340cbba888b0e9184f806a9ec0ac2c53f",
    "size": 241056,
    "noattachment": false,
    "tarball": "http://registry.npm.souche-inc.com/react-hotkeys/download/react-hotkeys-2.0.0.tgz"
  },
  "files": [
    "cjs",
    "umd",
    "es",
    "package.json",
    "README.md",
    "LICENSE",
    "index.js",
    "index.es.js",
    "index.d.ts"
  ],
  "globalExport": "ReactHotkeys",
  "homepage": "https://github.com/greena13/react-hotkeys",
  "keywords": [
    "react-component",
    "hotkeys",
    "focus",
    "react"
  ],
  "license": "ISC",
  "licenseText": "ISC License\n\nCopyright (c) 2018, Aleck Greenham\n\nPermission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n",
  "main": "index",
  "maintainers": [
    {
      "name": "chrisui",
      "email": "hello@chrispearce.me"
    },
    {
      "name": "greena13",
      "email": "greenhama13@gmail.com"
    }
  ],
  "module": "index.es",
  "name": "react-hotkeys",
  "optionalDependencies": {},
  "peerDependencies": {
    "react": ">= 0.14.0"
  },
  "publish_time": 1562914304141,
  "readme": "<p align=\"center\">\n  <img src=\"http://svgshare.com/i/3tk.svg\"><br/>\n  <h2 align=\"center\">React HotKeys</h2>\n</p>\n\n[![npm](https://img.shields.io/npm/dm/react-hotkeys.svg)]()\n[![Build Status](https://travis-ci.org/greena13/react-hotkeys.svg)](https://travis-ci.org/greena13/react-hotkeys)\n[![GitHub license](https://img.shields.io/github/license/greena13/react-hotkeys.svg)](https://github.com/greena13/react-hotkeys/blob/master/LICENSE)\n[![Maintainability](https://api.codeclimate.com/v1/badges/9eff94c396c9e8dd5d7b/maintainability)](https://codeclimate.com/github/greena13/react-hotkeys/maintainability)\n[![Gitter](https://img.shields.io/gitter/room/chrisui/react-hotkeys.svg)](https://gitter.im/chrisui/react-hotkeys)\n\nA declarative library for handling hotkeys and focus areas in React applications.\n\n### Upgrading from 1.\\*.\\* ?\n\nSee the [upgrade notes](https://github.com/greena13/react-hotkeys/releases/tag/v2.0.0).\n\n## Feature Overview\n\n- Minimal declarative [JSX](#HotKeys-component-API) and [HoC](#withHotKeys-HoC-API) APIs\n- [Browser key names](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) and [Mousetrap syntax](https://github.com/ccampbell/mousetrap)\n- Define [global](#GlobalHotKeys-component) and [in-focus](#HotKeys-component) hot keys\n- [Display a list of available hot keys to the user](#Displaying-a-list-of-available-hot-keys)\n- [Define custom key codes](#defining-custom-key-codes) for WebOS and other environments\n- Allow users to [set their own keyboard shortcuts](#setting-dynamic-hotkeys-at-runtime)\n- Works with React's Synthetic KeyboardEvents and event delegation and provides [predictable and expected behaviour](#Interaction-with-React) to anyone familiar with React\n- Optimized by default, but allows you to turn off different optimisation measures in a granular fashion\n- Customizable through a simple [configuration API](#Configuration)\n- [Optimized for larger applications](#Optimizations), with many hot keys active at once\n- Depends only on `prop-types` and a peer dependency of `react`\n- Uses rollup and Uglify and strips out comments and logging for a small production build\n- More than [2000 automated tests](https://github.com/greena13/react-hotkeys/tree/master/test)\n\n## Basic Usage\n\n#### Define a key map\n\n```javascript\nimport { HotKeys } from \"react-hotkeys\";\nimport MyNode from \"./MyNode\";\nimport React from 'react';\n\nconst keyMap = {\n  SNAP_LEFT: \"command+left\",\n  DELETE_NODE: [\"del\", \"backspace\"]\n};\n\nconst App = () => {\n  return (\n    <HotKeys keyMap={keyMap}>\n      <div>\n        <MyNode />\n        <MyNode />\n      </div>\n    </HotKeys>\n  );\n};\n\nexport default App;\n```\n\n#### Define handlers\n\n```javascript\nimport { HotKeys } from \"react-hotkeys\";\nimport React from 'react';\n\nconst MyNode = () => {\n  const handlers = {\n    DELETE_NODE: this.deleteNode\n  };\n\n  return <HotKeys handlers={handlers}>Node contents</HotKeys>;\n};\n\nexport default MyNode;\n```\n\n## Contents\n\n- [Licenses](#licenses)\n- [Support](#support)\n- [Install](#install)\n    - [CommonJS & ES6 Modules](#commonjs--es6-modules)\n        - [The latest pre-release](#the-latest-pre-release)\n    - [UMD](#umd)\n        - [Development build](#development-build)\n        - [Minified production build](#minified-production-build)\n    - [Bower](#bower)\n- [Defining key maps](#defining-key-maps)\n    - [Key Combinations vs Sequences](#key-combinations-vs-sequences)\n    - [Full Reference](#full-reference)\n    - [Alternative Hotkeys](#alternative-hotkeys)\n    - [Specifying key events (keydown, keypress, keyup)](#specifying-key-events-keydown-keypress-keyup)\n    - [Specifying key map display data](#specifying-key-map-display-data)\n    - [Deciding which key map syntax to use](#deciding-which-key-map-syntax-to-use)\n    - [Defining custom key codes](#defining-custom-key-codes)\n    - [Setting dynamic hotkeys at runtime](#setting-dynamic-hotkeys-at-runtime)\n- [Defining Handlers](#defining-handlers)\n    - [DEPRECATED: Hard Sequence Handlers](#deprecated-hard-sequence-handlers)\n- [Interaction with React](#interaction-with-react)\n- [HotKeys components](#hotkeys-components)\n- [HotKeys component API](#hotkeys-component-api)\n- [withHotKeys HoC API](#withhotkeys-hoc-api)\n    - [Simple use-case](#simple-use-case)\n    - [Pre-defining default prop values](#pre-defining-default-prop-values)\n- [GlobalHotKeys component](#globalhotkeys-component)\n- [GlobalHotKeys component API](#globalhotkeys-component-api)\n- [How actions are resolved](#how-actions-are-resolved)\n    - [How nested key maps are matched](#how-nested-key-maps-are-matched)\n    - [How combinations and sequences are matched](#how-combinations-and-sequences-are-matched)\n- [How action handlers are resolved](#how-action-handlers-are-resolved)\n- [Displaying a list of available hot keys](#displaying-a-list-of-available-hot-keys)\n- [Allowing hotkeys and handlers props to change](#allowing-hotkeys-and-handlers-props-to-change)\n- [Ignoring events](#ignoring-events)\n    - [What it actually means to ignore an event](#what-it-actually-means-to-ignore-an-event)\n    - [IgnoreKeys component](#ignorekeys-component)\n    - [IgnoreKeys component API](#ignorekeys-component-api)\n    - [withHotKeysIgnore HoC API](#withhotkeysignore-hoc-api)\n    - [ObserveKeys component](#observekeys-component)\n    - [ObserveKeys component API](#observekeys-component-api)\n    - [withObserveKeys HoC API](#withobservekeys-hoc-api)\n- [Configuration](#configuration)\n- [Logging](#logging)\n- [Optimizations](#optimizations)\n    - [Code optimizations](#code-optimizations)\n    - [Production optimizations](#production-optimizations)\n- [Managing focus in the browser](#managing-focus-in-the-browser)\n    - [Focusable elements](#focusable-elements)\n    - [Tab Index](#tab-index)\n    - [Autofocus](#autofocus)\n    - [Programmatically manage focus](#programmatically-manage-focus)\n    - [Get the element currently in focus](#get-the-element-currently-in-focus)\n- [Preventing default browser behaviour](#preventing-default-browser-behaviour)\n- [Troubleshooting & Gotchas](#troubleshooting--gotchas)\n    - [Hotkeys is wrapping my components in a div that is breaking my styling](#hotkeys-is-wrapping-my-components-in-a-div-that-is-breaking-my-styling)\n    - [Other keyboard event listeners are no longer being triggered](#other-keyboard-event-listeners-are-no-longer-being-triggered)\n    - [Actions aren't being triggered when using withHotKeys](#actions-arent-being-triggered-when-using-withhotkeys)\n    - [Actions aren't being triggered for HotKeys](#actions-arent-being-triggered-for-hotkeys)\n    - [React Hotkeys thinks I'm holding down a key I've released](#react-hotkeys-thinks-im-holding-down-a-key-ive-released)\n    - [Blue border appears around children of HotKeys](#blue-border-appears-around-children-of-hotkeys)\n- [Stability & Maintenance](#stability--maintenance)\n- [Contribute, please!](#contribute-please)\n    - [Using GitHub Issues](#using-github-issues)\n    - [Submitting a Pull Request](#submitting-a-pull-request)\n    - [Commit messages](#commit-messages)\n- [Build notes](#build-notes)\n    - [Build scripts](#build-scripts)\n    - [Development builds](#development-builds)\n    - [Production builds](#production-builds)\n    - [Build configuration](#build-configuration)\n- [Authorship](#authorship)\n\n\n\n## Licenses\n\n`react-hotkeys` is released under the [ISC License](/LICENSE). \n\nHowever, please note: the source code found in the lib/vendor directory is under the MIT License - please see the license file for each directory for more information.\n\n## Support\n\nIf you use React Hotkeys and it has saved you time or money, please consider contributing.  You will be supporting `react-hotkeys` by supporting its maintainer.\n\nPlease see my [Patreon Page](https://www.patreon.com/aleckgreenham) for details of why your support is needed, and how it will be used.\n \nFor recurring and publicly acknowledged support:\n\n| Payment Option | Link/Address |\n|:---|:----|\n| Patreon | https://www.patreon.com/aleckgreenham |\n\nFor one-off or irregular contributions:\n\n| Payment Option | Link/Address |\n|:---|:----|\n| Paypal | https://www.paypal.me/aleckgreenham |\n| Bitcoin | 1ETTdVEahUqBaGXRQaiEgMhVjYQU1jQKKT |\n| Ethereum | 0x6C9F9879f684e84314f5810f8F196bdB2c4e15c0 |\n| Stellar | GBJ5T7V7YVRN4D2PBZTOCWREJXYWWGNDIQGRFDGQAZNTYYIW7BMWDRYA |\n\n## Install\n\n### CommonJS & ES6 Modules\n\n`react-hotkeys` is available as a CommonJS or a ES6 Modules through npm or yarn. It uses `NODE_ENV` to determine whether to export the development or production build in your library or application.\n\nIt is expected you will use a bundling tool like Webpack or Uglify to remove the version of the bundle you are not using with each version of your application's code, to keep the library size to a minimum.\n\n#### The latest pre-release\n\n##### npm\n\n```\nnpm install react-hotkeys@next --save\n```\n\n##### yarn\n\n```\nyarn add react-hotkeys@next\n```\n\n#### Latest stable release\n\n##### npm\n\n```\nnpm install react-hotkeys --save\n```\n\n##### yarn\n\n```\nyarn add react-hotkeys\n```\n\n### UMD\n\n`react-hotkeys` as a UMD module is available on your CDN of choice.\n\nChange `1.0.1` for the version that you would like to use.\n\n#### Development build\n\n```\n<script crossorigin src=\"https://cdn.jsdelivr.net/npm/react-hotkeys@1.0.1/umd/react-hotkeys.js\"></script>\n```\n\n```\n<script crossorigin src=\"https://unpkg.com/react-hotkeys@1.0.1/umd/react-hotkeys.js\"></script>\n```\n\n#### Minified production build\n\n```\n<script crossorigin src=\"https://cdn.jsdelivr.net/npm/react-hotkeys@1.0.1/umd/react-hotkeys.min.js\"></script>\n```\n\n```\n<script crossorigin src=\"https://unpkg.com/react-hotkeys@1.0.1/umd/react-hotkeys.min.js\"></script>\n```\n\n### Bower\n\nBower support was removed in `v1.0.0`, but those who already rely on earlier versions of `react-hotkeys` through Bower can continue to do so using the following command:\n\n```\nbower install react-hotkeys@0.10.0\n```\n\nThe Bower version of the package will **not** be supported going forward (including fixing any outstanding issues).\n\n## Defining key maps\n\n`react-hotkeys` uses key maps to decouple defining keyboard shortcuts from the functions they call. This allows hot keys and handler functions to be defined and maintained independent of one another.\n\n> When a user presses the corresponding combination or sequence of keys, it is said they _match_ the hot keys, which causes an action to be _triggered_. `react-hotkeys` may then resolve an appropriate handler function to _handle_ the action.\n\nKey maps are Plain Old JavaScript Objects, where the keys are the action names and the values are usually a [Mousetrap-supported](https://craig.is/killing/mice) or [Browser Key Values](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) sequence string (but can also be an [array](#Alternative-Hotkeys) or an [object](#Key-Combination-vs-Sequences)) that must be matched in order to trigger the action.\n\n```javascript\nconst keyMap = {\n  deleteNode: \"del\",\n  moveUp: \"up\"\n};\n```\n\n#### Key Combinations vs Sequences\n\nEvery hotkey or sequence string is parsed and treated as a sequence of key combinations. The simplest case is a sequence of 1 key combination, consisting of 1 key: e.g. `'a'` or `'shift'`.\n\n```\n// Key sequence with a combination of a single key\n'4'\n\n// Special single key sequence (ie. shift is handled automagically)\n'?'\n\n// Sequence of a single combination with multiple keys (keys must be pressed at the same time)\n'command+shift+k'\n\n// Sequence of multiple combinations (keys must be pressed and released one after another)\n'up down left right'\n```\n\n#### Full Reference\n\nPlease refer to [Mousetrap's documentation](https://craig.is/killing/mice) or [Browser Key Values](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) for an exhaustive list of supported shortcuts and sequences.\n\n#### Alternative Hotkeys\n\nYou can specify multiple _alternative_ key sequences (they will trigger the same action) using arrays:\n\n```javascript\nconst keyMap = {\n  DELETE_NODE: [\"del\", \"backspace\"],\n  MOVE_UP: [\"up\", \"w\"]\n};\n```\n\n#### Specifying key events (keydown, keypress, keyup)\n\nBy default, `react-hotkeys` will match hotkey sequences on the `keydown` event (or, more precisely: on the `keydown` event of the last key to complete the last combination in a sequence).\n\nIf you want to trigger a single action on a different key event, you can use the object syntax and the `action` attribute to explicitly set which key event you wish to bind to:\n\n```javascript\nconst keyMap = {\n  CONTRACT: \"alt+down\",\n  COMMAND_DOWN: { sequence: \"command\", action: \"keydown\" }\n};\n```\n\nIf you want to change the default key event for all hotkeys, you can use the `defaultKeyEvent` option of the [configuration API](#Configuration).\n\nThe full list of valid key events is: `keypress`, `keydown`, and `keyup`.\n\n#### Specifying key map display data\n\nYou can specify data used to display the application's key maps using the object syntax and the `name`, `description` and `group` attributes (each are optional):\n\n```javascript\n  {\n    SHOW_DIALOG: { \n        name: 'Display keyboard shortcuts', \n        sequence: 'shift+?', \n        action: 'keyup' \n      }\n  }\n```\n\nIf you want to also provide alternative key sequences for the same action, use the `sequences` attribute:\n\n```javascript\n  {\n    SHOW_DIALOG: { \n        name: 'Display keyboard shortcuts', \n        sequences: ['shift+?', { sequence: '`', action: 'keyup' }], \n        action: 'keyup' \n      }\n  }\n```\n\n\n#### Deciding which key map syntax to use\n\nAs a general rule, you should use the syntax that is the most brief, but still allows you to express the configuration you want.\n\n| Syntax Type                  | Use when you ...                                                                                                    |\n| :--------------------------- | :------------------------------------------------------------------------------------------------------------------ |\n| String                       | Have a single key sequence and don't have any special requirements (Default case)                                   | \n| Array of strings             | Need alternative key maps that trigger the same action, and are happy with them triggering on the default key event |\n| Array of objects             | Need alternative key maps that trigger the same action, and want to them to trigger on a different key event        | \n| Object                       | Have a single key sequence and want to specify a different key event or display data                                | \n| Object (sequences attribute) | Have multiple key sequences that trigger the same action, and want to specify a different key event or display data | \n\n#### Defining custom key codes\n\nWhen you are working in a WebOS environment, or a similar, you may have need to define custom key codes. You can do so using the `customKeyCodes` [Configuration option](#configuration):\n\n```javascript\n\nimport {configure} from 'react-hotkeys';\n\nconfigure({\n  customKeyCodes: {\n    10009: 'BackTV'    \n  }\n})\n```\n\nOnce defined, you are then able to use the key names in you action sequences:\n\n```javascript\nconst keyMap = {\n  MY_ACTION: 'BackTV',\n};\n```\n\n#### Setting dynamic hotkeys at runtime\n\n`react-hotkeys` has basic support for setting dynamic hotkeys - i.e. letting the user set their own keyboard shortcuts at runtime. Once you have set up the necessary UI for [viewing the current keyboard shortcuts](#displaying-a-list-of-available-hot-keys) (and opting to change them), you can then use the `recordKeyCombination` function to capture the keys the user wishes to use.\n\n`recordKeyCombination` accepts a callback function that will be called on the last `keyup` of the next key combination - immediately after the user has pressed the key combination they wish to assign. The callback then unbinds itself, so you do not have to worry about tidying up after it.\n\n`recordKeyCombination` returns a function you can call at any time after binding the listener, to cancel listening without waiting for the key combination to complete. \n\nThe callback function receives a single argument with the following schema:\n\n```javascript\n{\n  /**\n   * Combination ID that can be passed to the keyMap prop to (re)define an\n   * action's key sequence \n   */\n  id: '',\n  /**\n   * Dictionary of keys involved in the combination\n   */\n  keys: { keyName: true }\n}\n\n// Example:\n\n{\n  id: 'a', \n  keys: { a: true }\n}\n```\n\nIf you are updating hotkeys without changing focus or remounting the component that defines them, you will need to make sure you use the [`allowChanges` prop](#hotkeys-component-api) to ensure the new keymaps are honoured immediately.\n \nAn example, rendering two dialogs: \n\n* One for displaying the application's key maps using the [getApplicationKeyMap](#displaying-a-list-of-available-hot-keys) function\n* Another for telling the user when to press the keys they want to bind to an action, meanwhile listening with `recordKeyCombination()` \n\n```javascript\nimport { recordKeyCombination } from 'react-hotkeys';\nimport React from 'react';\n\nrenderDialog(){\n  if (this.state.showShortcutsDialog) {\n    const keyMap = getApplicationKeyMap();\n\n    return (\n      <div style={styles.DIALOG}>\n        <h2>\n          Keyboard shortcuts\n        </h2>\n\n        <table>\n          <tbody>\n          { \n            Object.keys(keyMap).reduce((memo, actionName) => {\n              const { sequences, name } = keyMap[actionName];\n              \n              memo.push(\n                <tr key={name || actionName}>\n                  <td style={styles.KEYMAP_TABLE_CELL}>\n                    { name }\n                  </td>\n                  <td style={styles.KEYMAP_TABLE_CELL}>\n                    { sequences.map(({sequence}) => <span key={sequence}>{sequence}</span>) }\n                  </td>\n                  <td style={styles.KEYMAP_TABLE_CELL}>\n                    <button onClick={ () => this.showChangeShortcutDialog(actionName) }>\n                      Change\n                    </button>\n                  </td>\n                </tr>\n              );\n              \n              return memo;\n            })\n          }\n          </tbody>\n        </table>\n      </div>\n    );\n  } else if (this.state.changingActionShortcut) {\n    const { cancel } = this.state.changingActionShortcut;\n    \n    const keyMap = getApplicationKeyMap();\n    const { name } = keyMap[this.state.changingActionShortcut];\n    \n    return (\n      <div style={styles.DIALOG}>\n        Press the keys you would like to bind to #{name}.\n        \n        <button onClick={cancel}>\n          Cancel\n        </button>\n      </div>       \n    );\n  }\n}\n\nshowChangeShortcutDialog(actionName) {\n  const cancelListening = recordKeyCombination(({id}) => {\n      this.setState({\n        showShortcutsDialog: true,\n        changingActionShortcut: null,\n        keyMap: {\n          ...this.state.keyMap,\n          [actionName]: id      \n        }\n      }); \n  });\n  \n  this.setState({\n    showShortcutsDialog: false,\n    changingActionShortcut: {\n      cancel: () => {\n        cancelListening();\n        \n        this.setState({\n          showShortcutsDialog: true,\n          changingActionShortcut: null\n        }); \n      }\n    }\n  });    \n}\n```\n\n## Defining Handlers\n\nKey maps trigger actions when they match a key sequence. Handlers are the functions that `react-hotkeys` calls to handle those actions.\n\nHandlers may be defined in the same `<HotKeys />` component as the key map:\n\n```javascript\nimport { HotKeys } from \"react-hotkeys\";\nimport React from 'react';\n\nconst keyMap = {\n  MOVE_UP: \"up\"\n};\n\nconst handlers = {\n  MOVE_UP: event => console.log(\"Move up hotkey called!\")\n};\n\n<HotKeys keyMap={keyMap} handlers={handlers}>\n  <input />\n</HotKeys>;\n```\n\nOr they may be defined in any _descendant_ of the `<HotKeys />` component that defines the key map:\n\n```javascript\nimport { HotKeys } from \"react-hotkeys\";\nimport React from 'react';\n\nconst keyMap = {\n  MOVE_UP: \"up\"\n};\n\nconst handlers = {\n  MOVE_UP: event => console.log(\"Move up hotkey called!\")\n};\n\n<HotKeys keyMap={keyMap}>\n  <div>\n    <HotKeys handlers={handlers}>\n      <input />\n    </HotKeys>\n  </div>\n\n  <div>\n    <input />\n  </div>\n</HotKeys>;\n```\n\n#### DEPRECATED: Hard Sequence Handlers\n\nHandlers associated to actions with names that are valid key sequence strings implicitly define actions that are matched by the corresponding key sequence. This means you do not have to define the key maps in order for these handlers to \"just work\".\n\nThis functionality is not advised and exists mainly for backwards compatibility. It is generally advisable to explicitly define an action in a key map rather than rely on this behaviour.\n\nTo use hard sequence handlers, you must first enable them using the `enableHardSequences` [configuration option](#Configuration).\n\n```javascript\n/**\n * If no named 'up' action has been defined in a key map and it is a valid\n * key sequence, react-hotkeys assumes it's a hard sequence handler and\n * implicitly defines an action for it\n */\n\nconst handlers = {\n  up: event => console.log(\"up key called\")\n};\n```\n\n## Interaction with React\n\nRather than re-invent the wheel, `react-hotkeys` piggy-backs of the React SyntheticEvent and event propagation, so all of the normal React behaviour that you expect still applies.\n\n- Key events propagate up from a source or target towards the root of the application.\n- If an event has `stopPropagation()` called on it, it will not be seen by components higher up in the render tree.\n\n## HotKeys components\n\n`<HotKeys>` components listen only to key events that happen when one of their DOM-mounted descendents are in focus (`<div/>`, `<span/>`, `<input/>`, etc). This emulates (and re-uses) the behaviour of the browser and React's SyntheticEvent propagation.\n\nThis is the default type of `<HotKeys />` component, and should normally be your first choice for efficiency and clarity (the user generally expects keyboard input to affect the focused element in the browser).\n\n## HotKeys component API\n\nThe HotKeys component provides a declarative and native JSX syntax that is best for succinctly declaring hotkeys in a way that best maintains separation and encapsulation with regards to the rest of your code base.\n\nHowever, it [does require that its children be wrapped in a DOM-mounted node](#hotkeys-is-wrapping-my-components-in-a-div-that-is-breaking-my-styling), which can break styling and add extra levels to your render tree.\n\n```javascript\n\n<HotKeys\n  /**\n   * An object that defines actions as keys and key sequences as values\n   * (using either a string, array or object).\n   *\n   * Actions defined in one HotKeys component are available to be handled\n   * in an descendent HotKeys component.\n   *\n   * Optional.\n   */\n  keyMap={ {} }\n\n  /**\n   * An object that defines handler functions as values, and the actions\n   * that they handle as keys.\n   *\n   * Optional.\n   */\n  handlers={ {} }\n\n  /**\n   * The type of DOM-mountable component that should be used to wrap\n   * the component's children.\n   */\n  component={ 'div' }\n\n  /**\n   * tabindex value to pass to DOM-mountable component wrapping children\n   */\n  tabIndex={-1}\n\n  /**\n   * Whether the keyMap or handlers are permitted to change after the\n   * component mounts. If false, changes to the keyMap and handlers\n   * props will be ignored\n   *\n   * Optional.\n   */\n  allowChanges={false}\n\n  /**\n   * A ref to add to the underlying DOM-mountable node. Pass a function\n   * to get a reference to the node, so you can call .focus() on it\n   */\n  innerRef: {undefined}\n  \n  /**\n   * Whether this is the root HotKeys node - this enables some special \n   * behaviour\n   */\n  root={false}\n  >\n\n  /**\n   * Wraps all children in a DOM-mountable component\n   */\n   { children }\n\n</HotKeys>\n```\n\n## withHotKeys HoC API\n\nThe HotKeys component API is generally recommended, but if wrapping your component in a DOM-mountable node is not acceptable, or you need more control over how the `react-hotkeys` props are applied, then the `withHotKeys()` HoC is available.\n\n### Simple use-case\n\nThe simplest use-case of `withHotKeys()` is to simply pass it your component class as the first argument. What is returned is a new component that will accept all of the same props as a `<HotKey>` component, so you can specify key maps and handlers at render time, for example.\n\n> The component you wrap **must** take responsibility for passing the `hotKeys` props to a DOM-mountable element. If you fail to do this, key events will not be detected when a descendant of the component is in focus.\n\n```javascript\nimport { withHotKeys } from \"react-hotkeys\";\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const { hotKeys, ...remainingProps } = this.props;\n\n    return (\n      <div {...{ ...hotKeys, ...remainingProps }}>\n        <span>My HotKeys are effective here</span>\n\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\nconst MyHotKeysComponent = withHotKeys(MyComponent);\n\nconst keyMap = {\n  TEST: \"t\"\n};\n\nconst handlers = {\n  TEST: () => console.log(\"Test\")\n};\n\n<MyHotKeysComponent keyMap={keyMap} handlers={handlers}>\n  <div>You can press 't' to log to the console.</div>\n</MyHotKeysComponent>;\n```\n\n### Pre-defining default prop values\n\nYou can use the second argument of `withHotKeys` to specify default values for any props you would normally pass to `<HotKeys />`. This means you do not have to specify them at render-time.\n\n> If you do provide prop values when you render the component, these will be merged with (and override) those defined in the second argument of `withHotKeys`.\n\n```javascript\nimport { withHotKeys } from \"react-hotkeys\";\nimport React from 'react';\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const { hotKeys, ...remainingProps } = this.props;\n\n    return (\n      <div {...{ ...hotKeys, ...remainingProps }}>\n        <span>My HotKeys are effective here</span>\n\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\nconst keyMap = {\n  TEST: \"t\"\n};\n\nconst handlers = {\n  TEST: () => console.log(\"Test\")\n};\n\nconst MyHotKeysComponent = withHotKeys(MyComponent, { keyMap, handlers });\n\n/**\n * Render without having to specify prop values\n */\n<MyHotKeysComponent>\n  <div>You can press 't' to log to the console.</div>\n</MyHotKeysComponent>;\n```\n\n## GlobalHotKeys component\n\n`<GlobalHotKeys>` components match key events that occur anywhere in the document (even when no part of your React application is in focus).\n\n```javascript\nconst keyMap = { SHOW_ALL_HOTKEYS: \"shift+?\" };\nconst handlers = { SHOW_ALL_HOTKEYS: this.showHotKeysDialog };\n\n<GlobalHotKeys keyMap={keyMap} handlers={handlers} />;\n```\n\n`<GlobalHotKeys>` generally have no need for children, so should use a self-closing tag (as shown above). The only exception is when you are nesting other `<GlobalHotKeys>` components somewhere in the descendents (these are mounted before their parents, and so are generally matched first).\n\n## GlobalHotKeys component API\n\nThe GlobalHotKeys component provides a declarative and native JSX syntax for defining hotkeys that are applicable beyond you React application.\n\n```javascript\n<GlobalHotKeys\n  /**\n   * An object that defines actions as keys and key sequences as values\n   * (using either a string, array or object).\n   *\n   * Actions defined in one HotKeys component are available to be handled\n   * in an descendent HotKeys component.\n   *\n   * Optional.\n   */\n  keyMap={{}}\n  /**\n   * An object that defines handler functions as values, and the actions\n   * that they handle as keys.\n   *\n   * Optional.\n   */\n  handlers={{}}\n  /**\n   * Whether the keyMap or handlers are permitted to change after the\n   * component mounts. If false, changes to the keyMap and handlers\n   * props will be ignored\n   *\n   * Optional.\n   */\n  allowChanges={false}\n>\n  /** * Wraps all children in a DOM-mountable component */\n  {children}\n</GlobalHotKeys>\n```\n\n## How actions are resolved\n\n### How nested key maps are matched\n\nFor keymaps defined with `<HotKeys/>` components, how close your `<HotKeys/>` component is to the element currently focused in the DOM has the greatest affect on how actions are resolved. Whenever a key event occurs (`keydown`, `keypress` or `keyup`), `react-hotkeys` starts at the `<HotKeys/>` component closest to the event's target (the focused element in the browser) and searches up through the hierarchy of focused `<HotKeys/>` components, examining each `keyMap` for actions for which the current key completes the specified combination or sequence. \n\nRegardless of where `<GlobalHotKeys>` components appear in the render tree, they are matched with key events after the event has finished propagating through the React app (if the event originated in the React at all). This means if your React app is in focus and it handles a key event, it will be ignored by the `<GlobalHotKeys>` components.\n\nThe order used for resolving actions and handlers amongst `<GlobalHotKeys>` components, is the order in which they mounted (those mounted first, are given the chance to handle an action first). When a `<GlobalHotKeys>` component is unmounted, it is removed from consideration. This can get less deterministic over the course of a long session using a React app as components mount and unmount, so it is best to define actions and handlers that are globally unique.\n\nIt is recommended to use `<HotKeys>` components whenever possible for better performance and reliability.\n\n> You can use the [autofocus attributes](#Autofocus) or [programmatically manage focus](#Programmatically-manage-focus) to automatically focus your React app so the user doesn't have to select it in order for hot keys to take effect. It is common practice to place a `<HotKeys>` component towards the top of your application to match hot keys across your entire React application.\n\n### How combinations and sequences are matched\n\nFor key combinations, the action only matches if the key is the last one needed to complete the combination. For sequences, the action matches for the last key to complete the last combination in the sequence. \n\nBy default, sub-matches are disabled so if you have two actions bound to `cmd+a` and `a`, and you press the `cmd` key and then the `a` key (without releasing the `cmd` key), then the `cmd+a` combination is matched. This allows you to define longer, application-wide key combinations at the top of your app, without them being hidden by shorter context-dependent combinations in different parts of your app. However, it does depend on the order the keys are pressed: in the above example, if `a` was pressed first and then `cmd`, the `a` action would be matched. The trade-off for this behaviour is that combinations are not permitted to overlap: if you have two actions bound to `a` and `b` and the user presses `a` and then `b` without first releasing `a`, only the action associated with `a` will be called (because there are no actions associated with `a+b`). If you want allow sub-matches, you can use the [`allowCombinationSubmatches` configuration option](#configuration).\n\nThe match occurs on the key event you have specified when defining your keymap (the default is `keydown` if you have not overridden the [`defaultKeyEvent` configuration option](#configuration)).   \n\nOnce a matching action is found, `react-hotkeys` then searches for the corresponding action handler.\n\n## How action handlers are resolved\n\n> If one of the DOM-mounted descendents of an `<HotKeys>` component are in focus (and it is listening to key events) AND those key events match a hot key in the component's key map, then the corresponding action is triggered.\n\n`react-hotkeys` starts at the `<HotKeys/>` component closest to the event's target (the element that was in focus when the key was pressed) and works its way up through the component tree of focused `<HotKeys/>` components, looking for a matching handler for the action. The handler closest to the event target AND a descendant of the `<HotKeys/>` component that defines the action (or the component itself), is the one that is called.\n\nThat is:\n\n- Unless one of the DOM-mounted descendents of a `<HotKeys>` component is in focus, the component's actions are not matched\n- Unless a `<HotKeys>` component is nested within the `<HotKeys/>` component that defines the action (or is the same `<HotKeys />` component), its handler is not called\n- If a `<HotKeys />` component closer to the event target has defined a handler for the same action, a `<HotKeys />` component's handler won't be called (the closer component's handler will)\n\nA more exhaustive enumeration of `react-hotkeys` behaviour can be found by reviewing the [test suite](https://github.com/greena13/react-hotkeys/tree/master/test).\n\n## Displaying a list of available hot keys\n\n`react-hotkeys` provides the `getApplicationKeyMap()` function for getting a mapping of all actions and key sequences that have been defined by components that are currently mounted.\n\nThey are returned as an object, with the action names as keys, and the values are objects describing the key map.\n\nRegardless of which syntax you used to define the keymap, they always appear in the following format:\n\n```\n{\n  ACTION_NAME: {\n    /**\n     * Optional attributes - only present if you defined them\n     */\n     \n    name: 'name',\n    group: 'group',\n    description: 'description',\n    \n    /**\n     * Attributes always present\n     * /\n    sequences: [\n      {\n        action: 'keydown',\n        sequence: 'alt+s'\n      },\n      // ...\n    ]\n  },\n  // ... \n}\n```\n\nBelow is how the example application renders a dialog of all available hot keys:\n\n```javascript\nimport { getApplicationKeyMap } from 'react-hotkeys';\nimport React from 'react';\n\n// ...\n\nrenderDialog(){\n  if (this.state.showDialog) {\n    const keyMap = getApplicationKeyMap();\n\n    return (\n      <div style={styles.DIALOG}>\n        <h2>\n          Keyboard shortcuts\n        </h2>\n\n        <table>\n          <tbody>\n          { Object.keys(keyMap).reduce((memo, actionName) => {\n              const { sequences, name } = keyMap[actionName];\n              \n              memo.push(\n                <tr key={name || actionName}>\n                  <td style={styles.KEYMAP_TABLE_CELL}>\n                    { name }\n                  </td>\n                  <td style={styles.KEYMAP_TABLE_CELL}>\n                    { sequences.map(({sequence}) => <span key={sequence}>{sequence}</span>) }\n                  </td>\n                </tr>\n              );\n              \n              return memo;\n            })\n           }\n          </tbody>\n        </table>\n      </div>\n    );\n  }\n}\n```\n\n## Allowing hotkeys and handlers props to change\n\nFor performance reasons, by default `react-hotkeys` takes the `keyMap` and `handlers` prop values when `<HotKeys>` components are focused and when `<GlobalHotKeys>` components are mounted. It ignores all subsequent updates\nto their values when these props change.\n\nIf you need the ability to change them while `<HotKeys>` are still in focus, or while `<GlobalHotKeys>` are still mounted, then you can pass the `allowChanges` prop, permitting this behaviour for the particular component.\n\nIf you need to do this for all your `<HotKeys>` and `<GlobalHotKeys>` components, you can use the `ignoreKeymapAndHandlerChangesByDefault` option for the [Configuration API](#Configuration). This should normally never be done, as it can have significant performance implications.\n\n## Ignoring events\n\nBy default, all key events that originate from `<input>`, `<select>` or `<textarea>`, or have a `isContentEditable` attribute of `true` are ignored by `react-hotkeys`.\n\nIf this is not what you want for your application, you can modify the list of tags using the `ignoreTags` [configuration option](#Configuration) or if you need additional control, you can specify a brand new function using the `ignoreEventsCondition` [configuration option](#Configuration).\n\nIf you want an exception to the global ignore policy for a particular part of your app, then you can use the ObserveKeys component.\n\n### What it actually means to ignore an event\n\nWhen a keyboard event occurs, two things happen:\n\n* It's added to the record of the keys currently pressed (the current combination) and those were recently pressed (the current key sequence)\n* It's compared against the list of hotkeys you have defined\n\nWhen you ignore an event, if it's a keydown event (a new key is being pressed), it is not added to the key history and no attempt is made to match it against your hotkeys. If it's a keypress or a keyup event and the key already exists in the history, the event is recorded (the key is being released) but no attempt is made to find a corresponding hotkey.\n\nThis effectively means, no new ignored keys are recorded and any keys that are already pressed are recorded as being released so they don't bleed into subsequent key combinations.\n\n### IgnoreKeys component\n\n> You only need this component if you want to add extra key events to ignore, that are not already matched by `ignoreEventsCondition()`.\n\nIf you want `react-hotkeys` to ignore key events coming from a particular area of your app when it is in focus, you can use the `<IgnoreKeys/>` component:\n\n```javascript\nimport { IgnoreKeys } from \"react-hotkeys\";\nimport React from 'react';\n\n<IgnoreKeys>\n  /** * Children that, when in focus, should have its key events ignored by *\n  react hotkeys */\n</IgnoreKeys>;\n```\n\n### IgnoreKeys component API\n\nBy default, `<IgnoreKeys />` will ignore all key events, but you can customize this behaviour by providing a whitelist or blacklist of events to ignore:\n\n```javascript\n<IgnoreKeys\n    /**\n     * The whitelist of keys that keyevents should be ignored. i.e. if you place\n     * a key in this list, all events related to it will be ignored by react\n     * hotkeys.\n     *\n     * Accepts a string or an array of strings.\n     */\n      only: { [] }\n\n     /**\n      * The blacklist of keys that keyevents should be not ignored. i.e.\n      * if you place a key in this list, all events related to it will be\n      * still be observed by react hotkeys\n      */\n     except: { [] }\n    >\n\n    /**\n     * Children that, when in focus, should have its key events ignored by\n     * react hotkeys\n     */\n\n     { children }\n\n</IgnoreKeys>\n```\n\n### withHotKeysIgnore HoC API\n\nSimilar to the `<HotKeys>`'s `withHotKeys()` function, there is a `withIgnoreKeys()` function for achieving the `<IgnoreKeys>` functionality, without the need for rendering a surrounding DOM-mountable element.\n\n```javascript\nimport { withHotKeysIgnore } from \"react-hotkeys\";\nimport React from 'react';\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const { hotKeys, ...remainingProps } = this.props;\n\n    return (\n      <div {...{ ...hotKeys, ...remainingProps }}>\n        <span>HotKeys ignores key events from here</span>\n\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\nconst MyHotKeysComponent = withHotKeysIgnore(MyComponent);\n\n<MyHotKeysComponent except={\"Escape\"}>\n  <div>All key events except the 'Escape' key are ignored here</div>\n</MyHotKeysComponent>;\n```\n\n`withIgnoreKeys()` also accepts a second argument that becomes the default props of the component it returns:\n\n```javascript\nimport { withHotKeysIgnore } from \"react-hotkeys\";\nimport React from 'react';\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const { hotKeys, ...remainingProps } = this.props;\n\n    return (\n      <div {...{ ...hotKeys, ...remainingProps }}>\n        <span>HotKeys ignores key events from here</span>\n\n        {this.props.children}\n      </div>\n    );\n  }\n}\n\nconst MyHotKeysComponent = withHotKeysIgnore(MyComponent, { except: \"Escape\" });\n\n<MyHotKeysComponent>\n  <div>All key events except the 'Escape' key are ignored here</div>\n</MyHotKeysComponent>;\n```\n\n### ObserveKeys component\n\n> You only need this component if you want to add *exceptions* to the key events that are matched by `ignoreEventsCondition()` (i.e. you want to observe key events, even though they are globally ignored by default).\n\nIf you want `react-hotkeys` to always observe key events coming from a particular area of your app when it is in focus (despite the global `ignoreEventsCondition`), you can use the `<ObserveKeys/>` component:\n\n```javascript\nimport {ObserveKeys} from 'react-hotkeys';\nimport React from 'react';\n\n<ObserveKeys>\n    /**\n     * Children that, when in focus, should have its key events always\n     * observed by react hotkeys\n     */\n</ObserveKeys>\n```\n\n### ObserveKeys component API\n\nBy default, `<ObserveKeys />` will force all key events to be observed, but you can customize this behaviour by providing a whitelist or blacklist of events to ignore:\n\n```javascript\n<ObserveKeys\n    /**\n     * The whitelist of keys that keyevents should be forced to be observed.\n     * i.e. if you place a key in this list, all events related to it will be\n     * observed by react hotkeys - even if it's ignored by the\n     * ignoreEventsCondition.\n     *\n     * Accepts a string or an array of strings.\n     */\n      only: { [] }\n\n     /**\n      * The blacklist of keys that keyevents should be forced to be observed.\n      * i.e. if you place a key in this list, all events related to it will be\n      * still be ignored by react hotkeys if they match ignoreEventsCondition\n      */\n     except: { [] }\n    >\n\n    /**\n     * Children that, when in focus, should have its key events observed by\n     * react hotkeys - even if they match ignoreEventsCondition\n     */\n\n     { children }\n\n</ObserveKeys>\n```\n\n### withObserveKeys HoC API\n\nSimilar to the `<HotKeys>`'s `withHotKeys()` function, there is a `withObserveKeys()` function for achieving the `<ObserveKeys>` functionality, without the need for rendering a surrounding DOM-mountable element.\n\n```javascript\nimport {withObserveKeys} from 'react-hotkeys';\nimport React from 'react';\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const {hotKeys, ...remainingProps} = this.props;\n\n    return (\n      <div { ... { ...hotKeys, ...remainingProps } } >\n        <span>HotKeys always observes key events from here</span>\n\n       { this.props.children }\n      </div>\n    )\n  }\n}\n\nconst MyHotKeysComponent = withObserveKeys(MyComponent);\n\n<MyHotKeysComponent except={ 'Escape' }>\n  <div>\n    All key events except the 'Escape' key are observed here\n  </div>\n</MyHotKeysComponent>\n```\n\n`withObserveKeys()` also accepts a second argument that becomes the default props of the component it returns:\n\n```javascript\nimport {withObserveKeys} from 'react-hotkeys';\nimport React from 'react';\n\nclass MyComponent extends Component {\n  render() {\n    /**\n     * Must unwrap hotKeys prop and pass its values to a DOM-mountable\n     * element (like the div below).\n     */\n    const {hotKeys, ...remainingProps} = this.props;\n\n    return (\n      <div { ... { ...hotKeys, ...remainingProps } } >\n        <span>HotKeys observes key events from here</span>\n\n       { this.props.children }\n      </div>\n    )\n  }\n}\n\nconst MyHotKeysComponent = withObserveKeys(MyComponent, { except: 'Escape' });\n\n<MyHotKeysComponent>\n  <div>\n    All key events that match the ignoreEventsCondition are still observed here, except the 'Escape' key\n  </div>\n</MyHotKeysComponent>\n```\n\n## Configuration\n\nThe default behaviour across all `<HotKeys>` components is configured using the `configure` method.\n\n> configure() should be called as your app is initialising and before the first time you mount a `<HotKeys>` component anywhere your app.\n\nThe following options are available (**default values are shown**):\n\n```javascript\nimport {configure} from 'react-hotkeys';\n\nconfigure({\n  /**\n   * The level of logging of its own behaviour React HotKeys should perform.\n   */\n  logLevel: 'warn',\n\n  /**\n   * Default key event key maps are bound to (keydown|keypress|keyup)\n   */\n  defaultKeyEvent: 'keydown',\n\n  /**\n   * The default component type to wrap HotKey components' children in, to provide\n   * the required focus and keyboard event listening for HotKeys to function\n   */\n  defaultComponent: 'div',\n\n  /**\n   * The default tabIndex value passed to the wrapping component used to contain\n   * HotKey components' children. -1 skips focusing the element when tabbing through\n   * the DOM, but allows focusing programmatically.\n   */\n  defaultTabIndex: '-1',\n\n  /**\n   * The HTML tags that React HotKeys should ignore key events from. This only works\n   * if you are using the default ignoreEventsCondition function.\n   * @type {String[]}\n   */\n  ignoreTags: ['input', 'select', 'textarea'],\n\n  /**\n   * The function used to determine whether a key event should be ignored by React\n   * Hotkeys. By default, keyboard events originating elements with a tag name in\n   * ignoreTags, or a isContentEditable property of true, are ignored.\n   *\n   * @type {Function<KeyboardEvent>}\n   */\n  ignoreEventsCondition: function,\n\n  /**\n   * Whether to allow hard sequences, or the binding of handlers to actions\n   * that have names that are valid key sequences, which implicitly define\n   * actions that are triggered by that key sequence\n   */\n  enableHardSequences: false,\n\n  /**\n   * Whether to ignore changes to keyMap and handlers props by default\n   * (this reduces a significant amount of unnecessarily resetting\n   * internal state)\n   * @type {boolean}\n   */\n  ignoreKeymapAndHandlerChangesByDefault: true,\n\n  /**\n   * Whether to ignore repeated keyboard events when a key is being held down\n   * @type {boolean}\n   */\n  ignoreRepeatedEventsWhenKeyHeldDown: true,\n  \n  /**\n   * Whether React HotKeys should simulate keypress events for the keys that do not\n   * natively emit them.\n   * @type {boolean}\n   */\n  simulateMissingKeyPressEvents: true,\n\n  /**\n   * Whether to call stopPropagation() on events after they are\n   * handled (preventing the event from bubbling up any further, both within\n   * React Hotkeys and any other event listeners bound in React).\n   *\n   * This does not affect the behaviour of React Hotkeys, but rather what\n   * happens to the event once React Hotkeys is done with it (whether it's\n   * allowed to propagate any further through the Render tree).\n   */\n   stopEventPropagationAfterHandling: true,\n\n  /**\n   * Whether to call stopPropagation() on events after they are\n   * ignored (preventing the event from bubbling up any further, both within\n   * React Hotkeys and any other event listeners bound in React).\n   *\n   * This does not affect the behaviour of React Hotkeys, but rather what\n   * happens to the event once React Hotkeys is done with it (whether it's\n   * allowed to propagate any further through the Render tree).\n   */\n   stopEventPropagationAfterIgnoring: true,\n   \n   /**\n   * Whether to allow combination submatches - e.g. if there is an action \n   * bound to cmd, pressing shift+cmd will *not* trigger that action when\n   * allowCombinationSubmatches is false.\n   */\n  allowCombinationSubmatches: false,\n  \n  /**\n   * A mapping of custom key codes to key names that you can then use in your\n   * key sequences\n   */\n  customKeyCodes: {},\n});\n```\n\n## Logging\n\n`react-hotkeys` provides comprehensive logging of all of its internal behaviour and allows setting one of 6 log levels.\n\nThe default level is `warn`, which provides warnings and errors only, and is generally sufficient for most usage. However, if you are troubleshooting an issue or reporting a bug, you should increase the log level to `debug` or `verbose` to see what is going on, and be able to communicate it concisely.\n\nYou can set the logging level using the `logLevel` [configuration option](#Configuration).\n\nFor performance reasons, only some of the log levels are available in the production build. You will need to use the development build to get the full log output.\n\n| Log Level | Severity  | Description                             | Available in Dev | Available in Prod |\n| :-------- | :-------- | :-------------------------------------- | :--------------- | :---------------- |\n| verbose   | (highest) | `debug` + internal data representations | Yes              | No                |\n| debug     |           | `info` + event propagation info         | Yes              | No                |\n| info      |           | `warn` + general info                   | Yes              | No                |\n| warn      | (default) | `error` + warnings                      | Yes              | Yes               |\n| error     |           | Errors only (ignore warnings)           | Yes              | Yes               |\n| none      | (lowest)  | Log nothing                             | Yes              | Yes               |\n\nLogs appear in the developer console of the browser.\n\nEach line is prefixed with (where applicable):\n\n- The focus tree id\n- The component id\n- The event id\n\nEach id is also given a coloured emoticon, to make it easy to visually trace the propagation of particular events through multiple components.\n\n## Optimizations\n\n`react-hotkeys` uses a lot of optimizations to help keep it as performant as possible (both in terms of time and memory). It can be helpful to be aware of some of these measures if you are seeing unexpected behaviour:\n\n### Code optimizations\n\n- If an event is handled by an earlier handler, it is ignored by an further components (this is really a design decision, rather than an optimization, but it helps).\n- By default, `stopPropagation()` is called on all key events once `react-hotkeys` has handled them. This can be disabled via the `stopEventPropagationAfterHandling` and `stopEventPropagationAfterIgnoring` [configuration options](#Configuration).\n- Events are ignored unless an action exists that is bound to that particular event type (keydown, keypress, keyup)\n- Events are processed at each level, as they propagate up the React render tree. If a action is triggered by a leaf node, `react-hotkeys` stops there (and does not build the full application's mappings of key sequences and handlers)\n- Changes to keyMaps and handlers are ignored unless you explicitly opt-in to the behaviour of resetting them each time their prop value changes.\n- Key histories longer than the longest registered key sequence are discarded.\n- The mapping between an action's key sequences and handlers is built \"on-the-fly\", so unless a particular action is triggered, `react-hotkeys` doesn't do the work of finding its corresponding handler.\n- Global event listeners are only bound to `document` when a global hotkey is defined (and are removed when the last one is unmounted).\n\n### Production optimizations\n\n- The production build strips out all comments and logging statements below a level of warning, before undergoing minification using Uglify.\n- An es6 version is also available, that allows for tree-shaking in compatible build setups.\n\n## Managing focus in the browser\n\n### Focusable elements\n\nHTML5 allows any element with a `tabindex` attribute to receive focus.\n\nIf you wish to support HTML4 you are limited to the following focusable elements:\n\n- `<a>`\n- `<area>`\n- `<button>`\n- `<input>`\n- `<object>`\n- `<select>`\n- `<textarea>`\n\n### Tab Index\n\nIf no elements have a `tabindex` in a HTML document, the browser will tab between [focusable elements](#Focusable-elements) in the order that they appear in the DOM.\n\nIf there are elements with `tabindex` values greater than zero, they are iterated over first, according their `tabindex` value (from smallest to largest). Then the browser tabs over the focusable elements with a `0` or unspecified `tabindex` in the order that they appear in the DOM.\n\nIf any element is given a negative `tabindex`, it will be skipped when a user tabs through the document. However, a user may still click or touch on that element and it can be focused programmatically (see below).\n\n> By default, `<HotKeys>` render its children inside an element with a `tabindex` of `-1`. You can change this by passing a `tabIndex` prop to `<HotKeys>` or you can change the default `tabindex` value for all <HotKeys>`components using the`defaultTabIndex` option for the [Configuration API](#Configuration).\n\n### Autofocus\n\nHTML5 supports a boolean `autofocus` attribute on the following input elements:\n\n- `<button>`\n- `<input>`\n- `<select>`\n- `<textarea>`\n\nIt can be used to automatically focus parts of your React application, without the need to [programmatically manage focus](#Programmatically-manage-focus).\n\nOnly one element in the document should have this attribute at any one time (the last element to mount with the attribute will take effect).\n\n### Programmatically manage focus\n\nTo programmatically focus a DOM element, it must meet two requirements:\n\n- It must be a [focusable elements](#Focusable-element)\n- You must have a reference to it\n\nYou can get a reference to an element using React's `ref` property:\n\n```javascript\nclass MyComponent extends Component {\n  componentDidUpdate(prevProps) {\n    if (!prevProps.isFocused && this.props.isFocused) {\n      this._container.focus();\n    }\n  }\n\n  render() {\n    return <div ref={c => (this._container = c)}>My focusable content</div>;\n  }\n}\n```\n\nTo get a reference to the DOM-mountable node used as a wrapper by `<HotKeys />`, use the `innerRef` prop:\n\n```javascript\nclass MyComponent extends Component {\n    componentDidMount() {\n        this._container.focus();\n    }\n\n    render() {\n        return (\n            <HotKeys innerRef={ (c) => this._container = c } >\n                My focusable content\n            </div>\n        )\n    }\n\n}\n```\n\n### Get the element currently in focus\n\nYou can retrieve the element that is currently focused using the following:\n\n```javascript\ndocument.activeElement;\n```\n\n## Preventing default browser behaviour\n\nIf you find that you want to bind to a key sequence that is already used by the browser, you can prevent the default behaviour by calling the `preventDefault` method on the event object:\n\n```javascript\nevent.preventDefault();\n```\n\nIt's generally not advised to do this, as it likely violates the [Principle of Least Surprise](https://en.wikipedia.org/wiki/Principle_of_least_astonishment).\n\n## Troubleshooting & Gotchas\n\n#### Hotkeys is wrapping my components in a div that is breaking my styling\n\nYou have 3 options:\n\n1. Use the [`component` prop](#HotKeys-component-API) to specify a `span` or some other alternative DOM-mountable component to wrap your component in, each time you render a component you don't want to wrap in a div element.\n1. Use the [`defaultComponent` configuration option](#Configuration) to specify a `span` or some other alternative DOM-mountable component to wrap _all_ `<HotKeys>` children in.\n1. Use the [withHotKeys HoC API](#withHotKeys-HoC-API) to avoid rendering a wrapping component at all.\n\n#### Other keyboard event listeners are no longer being triggered\n\nFor improved performance, by default `react-hotkeys` calls `stopPropagation()` on all events that it handles. You can change this using the `stopEventPropagationAfterHandling` and `stopEventPropagationAfterIgnoring` [configuration options](#Configuration).\n\n#### Actions aren't being triggered when using withHotKeys\n\nCheck that you are [correctly passing the hotKeys props to a DOM-mountable component](#Pre-defining-default-prop-values).\n\n#### Actions aren't being triggered for HotKeys\n\nMake sure you are focusing a descendant of the `<HotKeys>` component before you press the keys.\n\nCheck that the `<HotKeys>` component that defines the handler is also an ancestor of the focused component, and is above (or _is_) the component that defines the `handlers`.\n\nAlso make sure your React application is not calling `stopPropagation()` on the key events before they reach the `<HotKeys>` component that defines the `keyMap`.\n\nFinally, make sure your key event are not coming from one of the [tags ignored by react-hotkeys](#Ignoring-events).\n\n#### React Hotkeys thinks I'm holding down a key I've released\n\nThis can happen when you have an action handler that either unmounts the `<HotKeys>` component, or focuses an area of the application where there is no ancestor `<HotKeys>`. The solution is to add a `<HotKeys>` component with the `root` prop to the top of your application - or at least high enough to *not* be unmounted or unfocused by your action handler.\n\n```javascript\n<HotKeys root>\n  // The parts of your application that are re-rendered or unfocused here\n</HotKeys>\n```\n\nAlternatively, you can add a `<GlobalHotKeys/>` component anywhere in your application and it will close key combinations left hanging by your `<HotKeys />` components due to missed `keypress` and `keyup` events.\n\n#### Blue border appears around children of HotKeys\n\n`react-hotkeys` adds a `<div />` around its children with a `tabindex=\"-1\"` to allow them to be programmatically focused. This can result in browsers rendering a blue outline around them to visually indicate that they are the elements in the document that is currently in focus.\n\nThis can be disabled using CSS similar to the following:\n\n```css\ndiv[tabindex=\"-1\"]:focus {\n  outline: 0;\n}\n```\n\n## Support\n\nPlease use [Gitter](https://gitter.im/Chrisui/react-hotkeys) to ask any questions you may have regarding how to use `react-hotkeys`.\n\nIf you believe you have found a bug or have a feature request, please [open an issue](https://github.com/greena13/react-hotkeys/issues).\n\n## Stability & Maintenance\n\n`react-hotkeys` is considered stable and already being widely used (most notably Lystable and Whatsapp).\n\n## Contribute, please!\n\nIf you're interested in helping out with the maintenance of `react-hotkeys`, make yourself known on [Gitter](https://gitter.im/Chrisui/react-hotkeys), [open an issue](https://github.com/greena13/react-hotkeys/issues) or create a pull request.\n\nAll contributions are welcome and greatly appreciated - from contributors of all levels of experience.\n\nCollaboration is loosely being coordinated across [Gitter](https://gitter.im/Chrisui/react-hotkeys) and [Projects](https://github.com/greena13/react-hotkeys/projects).\n\n### Using GitHub Issues\n\n- Use the search feature to check for an existing issue\n- Include as much information as possible and provide any relevant resources (Eg. screenshots)\n- For bug reports ensure you have a reproducible test case\n  - A pull request with a breaking test would be super preferable here but isn't required\n\n### Submitting a Pull Request\n\n- Squash commits\n- Lint your code with eslint (config provided)\n- Include relevant test updates/additions\n\n### Commit messages\n\nThis repository uses the [meaningful emoji commits](http://greena13.github.io/blog/2016/08/19/emojis-are-the-solution-to-useless-commit-messages/) convention to help atomise and label commits.\n\n## Build notes\n\n`react-hotkeys` uses a mixture of build tools to create each of the development and production bundles, which can be confusing to navigate and understand.\n\n### Build scripts\n\nAll build commands are included in the `package.json`:\n\n| Command                      | Description                                                                                |\n| :--------------------------- | :----------------------------------------------------------------------------------------- |\n| `yarn prepublish`            | Build all bundles using babel and rollup                                                   |\n| `yarn build-cjs`             | Build the development and production CommonJS bundles using babel and rollup, respectively |\n| `yarn build-es`              | Build the development and production ES6 bundles using babel and rollup, respectively      |\n| `yarn build-umd`             | Build the development and production UMD bundles using rollup                              |\n| `yarn build-development`     | Build the development CommonJS bundle using babel                                          |\n| `yarn build-es-development`  | Build the development ES6 bundle using babel                                               |\n| `yarn build-umd-development` | Build the development ES6 bundle using rollup                                              |\n| `yarn build-production`      | Build the production CommonJS bundle using rollup                                          |\n| `yarn build-es-production`   | Build the production ES6 bundle using rollup                                               |\n| `yarn build-umd-production`  | Build the production ES6 bundle using rollup                                               |\n\n### Development builds\n\n| Bundle   | Transpiled with | Modularized with | Output        |\n| :------- | :-------------- | :--------------- | :------------ |\n| CommonJS | Babel           | Babel            | /cjs/index.js |\n| UMD      | Babel           | Rollup           | /umd/index.js |\n| ES6      | Babel           | Babel            | /es/index.js  |\n\n### Production builds\n\n| Bundle   | Transpiled with | Optimized with | Minified with | Output                              |\n| :------- | :-------------- | :------------- | :------------ | :---------------------------------- |\n| CommonJS | Babel           | Rollup         | Uglify        | cjs/react-hotkeys.production.min.js |\n| UMD      | Babel           | Rollup         | Uglify        | /umd/react-hotkeys.min.js           |\n| ES6      | Babel           | Rollup         | Babel-minify  | /es/react-hotkeys.production.min.js |\n\n### Build configuration\n\nTo understand the configuration for any one build, you need to consult 3 places:\n\n- The CLI arguments used in the `scripts` of `package.json`\n- The `.babelrc` file (match the env to the `BABEL_ENV` value set in `scripts` above)\n- The `rollup.configs.js` (if applicable)\n\n## Authorship\n\nAll credit, and many thanks, goes to [Chris Pearce](https://github.com/Chrisui) for the inception of `react-hotkeys` and all versions before `1.0.0`.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/greena13/react-hotkeys.git"
  },
  "scripts": {
    "build-cjs": "rm -rf cjs && npm run build-development && npm run build-production",
    "build-development": "cross-env BABEL_ENV=development NODE_ENV=development babel src -d cjs",
    "build-es": "rm -rf es && npm run build-es-development && npm run build-es-production",
    "build-es-development": "cross-env BABEL_ENV=es-development NODE_ENV=development babel src -d es",
    "build-es-production": "cross-env BABEL_ENV=es-production NODE_ENV=production rollup --format es -c --file es/react-hotkeys.production.min.js",
    "build-production": "cross-env BABEL_ENV=production NODE_ENV=production rollup --format cjs -c --file cjs/react-hotkeys.production.min.js",
    "build-umd": "rm -rf umd && npm run build-umd-development && npm run build-umd-production",
    "build-umd-development": "cross-env BABEL_ENV=umd-development NODE_ENV=development rollup --format umd --name ReactHotkeys -c --file umd/react-hotkeys.js",
    "build-umd-production": "cross-env BABEL_ENV=production NODE_ENV=production rollup --format umd --name ReactHotkeys -c --file umd/react-hotkeys.min.js",
    "lint": "eslint .",
    "prepublish": "npm run build-cjs && npm run build-es && npm run build-umd",
    "tests": "mocha",
    "watch-tests": "mocha --watch"
  },
  "typings": "./index.d.ts",
  "version": "2.0.0"
}
